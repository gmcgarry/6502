ACIACS  EQU $D800
ACIADA  EQU ACIACS+1

NMIVEC	EQU $7FFA	; write actual NMI vector here
IRQVEC	EQU $7FFE	; write IRQ vector here

	.section dseg
	.org	$00FB
CKSM	.RS	1	; CHECKSUM
BYTECT  .RS	1	; GETBYTE COUNT
XLO	.RS	1	; XREG LOW
XHI	.RS	1	; XREG HIGH
SAVE	.RS	1

	.section cseg
	.base	$E000
	.org	$FE00

GETC	LDA	ACIACS
	LSR
	BCC	GETC	; RECEIVE NOT READY
	LDA	ACIADA	; INPUT CHARACTER
	AND	#$7F	; RESET PARITY BIT
	CMP	#$7F
	BEQ	GETC	; RUBOUT; IGNORE
	JMP	PUTC	; ECHO CHAR

KBHIT	LDA	ACIACS
	LSR
	RTS

GETHEX	JSR	GETC
	CMP	#'9'+1
	BCC	1f
	SBC	#7+1
1:	SBC	#'0'-1
	RTS

PUTHEX	PHA
	JSR	OUTHL
	PLA
	PHA
	JSR	OUTHR
	PLA
	RTS

OUT4H	LDY	#$00
	LDA	(XLO),Y	; OUTPUT 2 HEX CHAR
	JSR	OUTHL	; OUT LEFT HEX CHAR
	LDA	(XLO),Y
	JMP	OUTHR	; OUT RIGHT HEX CHAR

OUTHL   LSR		; OUT HEX LEFT BCD DIGIT
	LSR
	LSR
	LSR
OUTHR   AND	#$0F	; OUT HEX RIGHT BCD DIGIT
	CMP	#$0A
	BCC	1f
	ADC	#$6
1:	ADC	#'0'

PUTC	PHA
1:	LDA	ACIACS
	LSR
	LSR
	BCC	1b	; XMIT NOT READY
	PLA
	STA	ACIADA	; OUTPUT CHARACTER
	RTS

OUTSP	LDA	#' '	; SPACE
	JMP	PUTC	; (JSR & RTS)

OUTCR	LDA	#'\r'
	JSR	PUTC
	LDA	#'\n'
	JMP	PUTC

PUTS	PLA
        STA	XLO
        PLA
        STA	XHI
3:	LDY	#1
        LDA	(XLO),Y         ; Get the next string character
        INC	XLO		; update the pointer
        BNE	1f		; if not, we're pointing to next character
        INC	XHI		; account for page crossing
1:	ORA	#0              ; Set flags according to contents of Accumulator
        BEQ	2f		; don't print the final NULL
        JSR	PUTC		; write it out
        JMP	3b		; back around
2:	INC	XLO		;
        BNE	1f		;
        INC	XHI		; account for page crossing
1:	JMP	(XLO)		; return to byte following final NULL
	RTS

LOAD	LDA	#$11
	JSR	PUTC
1:	JSR	GETC
	CMP	#'S'
	BNE	1b	; 1ST CHAR NOT (S)
	JSR	GETC	; READ CHAR
	CMP	#'9'
	BEQ	9f
	CMP	#'1'
	BNE	1b	; 2ND CHAR NOT (1)
	LDY	#$00
	STY	CKSM	; ZERO CHECKSUM
	JSR	GETBYTE	; READ GETBYTE
	SUB	#2
	STA	BYTECT	; GETBYTE COUNT
	JSR	BADDR	; BUILD ADDRESS
2:	JSR	GETBYTE	; STORE DATA
	DEC	BYTECT
	BEQ	3f	; ZERO GETBYTE COUNT
	STA	(XLO),Y	; STORE PATH
	INC	XLO
	BNE	2b
	INC	XHI
	JMP	2b
3:	INC	CKSM
	BEQ	1b
ERROR	LDA	#'?'	; PRINT QUESTION MARK
	JSR	PUTC
9:	JSR	OUTCR
	JMP	CONTRL

BADDR	JSR	GETBYTE
	STA	XHI
	JSR	GETBYTE
	STA	XLO
	RTS

GETBYTE JSR	GETHEX	; GET HEX CHAR
	ASL
	ASL
	ASL
	ASL
	STA	SAVE
	JSR	GETHEX
	AND	#$0F	; MASK TO 4 BITS
	ADD	SAVE
	PHA
	ADD	CKSM
	STA	CKSM
	PLA
	RTS

JUMP	JSR	BADDR	; build ADDRESS
	JMP	(XLO)

; CHANGE MEMORY (M AAAA DD NN)
CHANGE	JSR	BADDR	; BUILD ADDRESS
	JSR	OUTSP	; PRINT SPACE
	JSR	OUT4H
	JSR	OUTSP	; PRINT SPACE
	JSR	GETBYTE
	LDY	#$00
	STA	(XLO),Y
	CMP	(XLO),Y
	BNE	ERROR	; MEMORY DID NOT CHANGE
	JMP	CONTRL

DUMP:
	JSR	BADDR
	JSR	OUTCR
	LDX	#$10
1:	JSR	OUT4H
	INC	XLO
	BNE	2f
	INC	XHI
2:	JSR	OUTSP
	DEX
	BNE	1b
	JMP	CONTRL

; ENTER POWER ON SEQUENCE
START	SEI
	CLD

	LDA	#START/256	; Initialize the interrupt vectors
	STA	NMIVEC+1	; User program may change
	STA	IRQVEC+1
	LDA	#START&$FF
	STA	NMIVEC
	STA	IRQVEC

	LDA	#$03
	STA	ACIACS
	NOP
	NOP
	NOP
	LDA	#$15	; SET SYSTEM PARAMETERS
	STA	ACIACS
   
CONTRL	LDX	#$FF
	TXS		; SET STACK POINTER
	JSR	OUTCR
	LDA	#'>'
	JSR	PUTC

	JSR	GETC	; READ CHARACTER
	PHA
	JSR	OUTSP	; PRINT SPACE
	PLA
	CMP	#'D'
	BEQ	DUMP
	CMP	#'L'
	BEQ	LOAD
	CMP	#'M'
	BEQ	CHANGE
	CMP	#'J'
	BEQ	JUMP
	JMP	CONTRL

; User "shadow" vectors:
GOIRQ	jmp	(IRQVEC)
GONMI	jmp	(NMIVEC)
GORST	jmp	START

	.org	$FFC0
	JMP	START	; $FFC0
	JMP	GETC	; $FFC3
	JMP	PUTC	; $FFC6
	JMP	PUTS	; $FFC9
	JMP	KBHIT	; $FFCC
	JMP	PUTHEX	; $FFCF
	JMP	GETHEX	; $FFD2
	JMP	OUTSP	; $FFD5
	JMP	OUTCR	; $FFD8

	.org	$FFFA
	.word	GONMI
	.word	GORST
	.word	GOIRQ

	.end
